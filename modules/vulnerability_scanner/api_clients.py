# -*- coding: utf-8 -*-
"""
API clients for vulnerability databases
"""
import os
import time
import requests
from typing import List, Dict, Any, Optional
from .models import Vulnerability


class APIClient:
    """Base API client with rate limiting and error handling"""
    
    def __init__(self, base_url: str, timeout: int = 15):
        self.base_url = base_url
        self.timeout = timeout
        self.last_request_time = 0
        self.min_request_interval = 0.5  # 500ms between requests
    
    def _rate_limit(self):
        """Implement simple rate limiting"""
        elapsed = time.time() - self.last_request_time
        if elapsed < self.min_request_interval:
            time.sleep(self.min_request_interval - elapsed)
        self.last_request_time = time.time()
    
    def _make_request(self, method: str, url: str, **kwargs) -> Optional[Dict]:
        """Make HTTP request with error handling"""
        self._rate_limit()
        
        try:
            kwargs['timeout'] = self.timeout
            response = requests.request(method, url, **kwargs)
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 429:
                print(f"      ⚠️  Rate limited, waiting...")
                time.sleep(2)
                return None
            else:
                return None
        
        except requests.exceptions.Timeout:
            print(f"      ⚠️  Request timeout")
            return None
        except requests.exceptions.RequestException as e:
            print(f"      ⚠️  Request error: {e}")
            return None
        except Exception as e:
            print(f"      ⚠️  Unexpected error: {e}")
            return None


class OSVClient(APIClient):
    """Client for OSV (Open Source Vulnerabilities) API"""
    
    def __init__(self):
        super().__init__("https://api.osv.dev")
    
    def query_package(self, package: str, version: str, ecosystem: str) -> List[Vulnerability]:
        """
        Query OSV database for vulnerabilities in a specific package version
        """
        vulnerabilities = []
        
        payload = {
            "package": {
                "name": package,
                "ecosystem": ecosystem
            },
            "version": version
        }
        
        data = self._make_request('POST', f"{self.base_url}/v1/query", json=payload)
        
        if data and 'vulns' in data:
            for vuln in data['vulns']:
                # Extract vulnerability details
                vuln_id = vuln.get('id', 'UNKNOWN')
                summary = vuln.get('summary', vuln.get('details', 'No summary available'))
                
                # Determine severity
                severity = 'UNKNOWN'
                if 'severity' in vuln:
                    for sev in vuln['severity']:
                        if sev.get('type') == 'CVSS_V3':
                            score_val = sev.get('score')
                            if score_val:
                                # Handle both numeric scores and CVSS vector strings
                                try:
                                    if isinstance(score_val, (int, float)):
                                        severity = self._cvss_to_severity(float(score_val))
                                        break
                                    elif isinstance(score_val, str):
                                        # Extract numeric score from CVSS vector if present
                                        # Format: "CVSS:3.1/AV:N/AC:L..." or just "7.5"
                                        import re
                                        match = re.search(r'(\d+\.?\d*)', score_val)
                                        if match:
                                            numeric_score = float(match.group(1))
                                            # Only use if it's a valid CVSS score (0-10)
                                            if 0 <= numeric_score <= 10:
                                                severity = self._cvss_to_severity(numeric_score)
                                                break
                                except (ValueError, AttributeError):
                                    pass  # Skip this severity entry
                        
                        # Fallback: use severity from database if no CVSS score
                        if severity == 'UNKNOWN' and 'score' not in sev:
                            # OSV sometimes provides direct severity strings
                            severity_str = sev.get('severity', '').upper()
                            if severity_str in ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']:
                                severity = severity_str
                                break
                
                # Get affected versions and fixed version
                affected_versions = []
                fixed_version = None
                if 'affected' in vuln:
                    for affected in vuln['affected']:
                        if 'versions' in affected:
                            affected_versions.extend(affected['versions'])
                        if 'ranges' in affected:
                            for range_info in affected['ranges']:
                                if 'events' in range_info:
                                    for event in range_info['events']:
                                        if 'fixed' in event:
                                            fixed_version = event['fixed']
                                            break
                
                # Get references
                references = []
                if 'references' in vuln:
                    references = [ref.get('url', '') for ref in vuln['references'] if ref.get('url')]
                
                # Check for exploits
                exploit_available = any('exploit' in ref.lower() for ref in references)
                
                # Published date
                published = vuln.get('published', '')
                
                # Extract aliases (includes CVE IDs)
                aliases = vuln.get('aliases', [])
                
                vulnerabilities.append(Vulnerability(
                    id=vuln_id,
                    summary=summary[:200],  # Truncate long summaries
                    severity=severity,
                    source='OSV',
                    affected_versions=affected_versions[:5],  # Limit list size
                    fixed_version=fixed_version,
                    references=references[:5],  # Limit references
                    exploit_available=exploit_available,
                    published_date=published,
                    aliases=aliases  # Include aliases for CVE mapping
                ))
        
        return vulnerabilities
    
    @staticmethod
    def _cvss_to_severity(score: float) -> str:
        """Convert CVSS score to severity level"""
        if score >= 9.0:
            return 'CRITICAL'
        elif score >= 7.0:
            return 'HIGH'
        elif score >= 4.0:
            return 'MEDIUM'
        elif score >= 0.1:
            return 'LOW'
        return 'INFO'


class NVDClient(APIClient):
    """Client for NVD (National Vulnerability Database) API"""
    
    def __init__(self, api_key: Optional[str] = None):
        super().__init__("https://services.nvd.nist.gov")
        self.api_key = api_key or os.getenv('NVD_API_KEY')
        
        # NVD has strict rate limits
        if self.api_key:
            self.min_request_interval = 0.6  # 50 requests per 30 seconds with key
        else:
            self.min_request_interval = 6.0  # 5 requests per 30 seconds without key
    
    def query_package(self, package: str) -> List[Vulnerability]:
        """
        Query NVD for CVEs related to a package
        Note: NVD searches by keyword, not specific versions
        """
        vulnerabilities = []
        
        params = {
            'keywordSearch': package,
            'resultsPerPage': 10
        }
        
        headers = {}
        if self.api_key:
            headers['apiKey'] = self.api_key
        
        data = self._make_request(
            'GET',
            f"{self.base_url}/rest/json/cves/2.0",
            params=params,
            headers=headers
        )
        
        if data and 'vulnerabilities' in data:
            for item in data['vulnerabilities']:
                cve = item.get('cve', {})
                
                cve_id = cve.get('id', 'UNKNOWN')
                
                # Extract description
                descriptions = cve.get('descriptions', [])
                summary = 'No description available'
                for desc in descriptions:
                    if desc.get('lang') == 'en':
                        summary = desc.get('value', summary)
                        break
                
                # Extract CVSS score and severity
                severity = 'UNKNOWN'
                cvss_score = None
                
                metrics = cve.get('metrics', {})
                if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
                    cvss_data = metrics['cvssMetricV31'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore')
                    severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                elif 'cvssMetricV3' in metrics and metrics['cvssMetricV3']:
                    cvss_data = metrics['cvssMetricV3'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore')
                    severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
                    cvss_data = metrics['cvssMetricV2'][0].get('cvssData', {})
                    cvss_score = cvss_data.get('baseScore')
                    if cvss_score:
                        if cvss_score >= 7.0:
                            severity = 'HIGH'
                        elif cvss_score >= 4.0:
                            severity = 'MEDIUM'
                        else:
                            severity = 'LOW'
                
                # Extract references
                references = []
                refs = cve.get('references', [])
                for ref in refs[:5]:  # Limit to 5
                    if 'url' in ref:
                        references.append(ref['url'])
                
                # Check for exploits
                exploit_available = any('exploit' in ref.lower() for ref in references)
                
                # Published date
                published = cve.get('published', '')
                
                # For NVD, the ID is already a CVE, include it in aliases too
                aliases = [cve_id] if cve_id.startswith('CVE-') else []
                
                vulnerabilities.append(Vulnerability(
                    id=cve_id,
                    summary=summary[:200],
                    severity=severity.upper(),
                    source='NVD',
                    cvss_score=cvss_score,
                    references=references,
                    exploit_available=exploit_available,
                    published_date=published,
                    aliases=aliases  # Include CVE ID in aliases
                ))
        
        return vulnerabilities


class GitHubAdvisoryClient(APIClient):
    """Client for GitHub Security Advisories API"""
    
    def __init__(self, token: Optional[str] = None):
        super().__init__("https://api.github.com")
        self.token = token or os.getenv('GITHUB_TOKEN')
        self.min_request_interval = 1.0  # GitHub has rate limits
    
    def query_package(self, package: str, ecosystem: str) -> List[Vulnerability]:
        """
        Query GitHub Security Advisories for a package
        """
        if not self.token:
            return []  # Requires authentication
        
        vulnerabilities = []
        
        # Map ecosystem names to GitHub format
        ecosystem_map = {
            'PyPI': 'PIP',
            'npm': 'NPM',
            'Maven': 'MAVEN',
            'NuGet': 'NUGET',
            'RubyGems': 'RUBYGEMS'
        }
        
        gh_ecosystem = ecosystem_map.get(ecosystem, ecosystem.upper())
        
        # GraphQL query
        query = """
        query($ecosystem: SecurityAdvisoryEcosystem!, $package: String!) {
          securityVulnerabilities(first: 10, ecosystem: $ecosystem, package: $package) {
            edges {
              node {
                advisory {
                  ghsaId
                  summary
                  severity
                  publishedAt
                  references { url }
                }
                vulnerableVersionRange
                firstPatchedVersion { identifier }
              }
            }
          }
        }
        """
        
        variables = {
            'ecosystem': gh_ecosystem,
            'package': package
        }
        
        headers = {
            'Authorization': f'Bearer {self.token}',
            'Content-Type': 'application/json'
        }
        
        data = self._make_request(
            'POST',
            f"{self.base_url}/graphql",
            json={'query': query, 'variables': variables},
            headers=headers
        )
        
        if data and 'data' in data and 'securityVulnerabilities' in data['data']:
            edges = data['data']['securityVulnerabilities'].get('edges', [])
            
            for edge in edges:
                node = edge.get('node', {})
                advisory = node.get('advisory', {})
                
                ghsa_id = advisory.get('ghsaId', 'UNKNOWN')
                summary = advisory.get('summary', 'No summary available')
                severity = advisory.get('severity', 'UNKNOWN')
                published = advisory.get('publishedAt', '')
                
                # Get references
                refs = advisory.get('references', [])
                references = [ref.get('url', '') for ref in refs if ref.get('url')]
                
                # Get version information
                vuln_range = node.get('vulnerableVersionRange', '')
                patched = node.get('firstPatchedVersion')
                fixed_version = patched.get('identifier') if patched else None
                
                # Extract CVE identifiers from advisory
                cve_identifiers = []
                identifiers = advisory.get('identifiers', [])
                for ident in identifiers:
                    if ident.get('type') == 'CVE':
                        cve_identifiers.append(ident.get('value'))
                
                vulnerabilities.append(Vulnerability(
                    id=ghsa_id,
                    summary=summary[:200],
                    severity=severity.upper(),
                    source='GitHub',
                    affected_versions=[vuln_range] if vuln_range else [],
                    fixed_version=fixed_version,
                    references=references[:5],
                    published_date=published,
                    aliases=cve_identifiers  # Include CVE IDs from GitHub
                ))
        
        return vulnerabilities


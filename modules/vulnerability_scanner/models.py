# -*- coding: utf-8 -*-
"""
Data models for vulnerability scanner
"""
from typing import List, Dict, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime


@dataclass
class Dependency:
    """Represents a project dependency"""
    package: str
    version: str
    ecosystem: str  # PyPI, npm, Maven, etc.
    source_file: str = ""
    
    def __str__(self):
        return f"{self.package}=={self.version} [{self.ecosystem}]"


@dataclass
class Vulnerability:
    """Represents a security vulnerability"""
    id: str  # CVE-ID, GHSA-ID, or OSV-ID
    summary: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    source: str  # osv, nvd, github
    affected_versions: List[str] = field(default_factory=list)
    fixed_version: Optional[str] = None
    references: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    exploit_available: bool = False
    published_date: Optional[str] = None
    aliases: List[str] = field(default_factory=list)  # Alternative IDs including CVE numbers
    
    def get_severity_color(self) -> str:
        """Get color code for severity level"""
        severity_map = {
            'CRITICAL': '#8B0000',
            'HIGH': '#c0392b',
            'MEDIUM': '#e67e22',
            'LOW': '#f39c12',
            'INFO': '#3498db'
        }
        return severity_map.get(self.severity.upper(), '#7f8c8d')


@dataclass
class PackageVulnerabilities:
    """Vulnerabilities found for a specific package"""
    dependency: Dependency
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    
    def get_total_count(self) -> int:
        """Get total vulnerability count"""
        return len(self.vulnerabilities)
    
    def get_severity_counts(self) -> Dict[str, int]:
        """Get count by severity"""
        counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        for vuln in self.vulnerabilities:
            severity = vuln.severity.upper()
            if severity in counts:
                counts[severity] += 1
        return counts
    
    def get_highest_severity(self) -> str:
        """Get the highest severity level"""
        severity_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO']
        for severity in severity_order:
            if any(v.severity.upper() == severity for v in self.vulnerabilities):
                return severity
        return 'UNKNOWN'


@dataclass
class ScanResult:
    """Complete scan result for a project"""
    project_path: str
    scan_timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    packages: List[PackageVulnerabilities] = field(default_factory=list)
    total_dependencies: int = 0
    total_vulnerabilities: int = 0
    scan_duration: float = 0.0
    errors: List[str] = field(default_factory=list)
    
    def get_summary(self) -> Dict[str, Any]:
        """Get scan summary statistics"""
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'INFO': 0}
        vulnerable_packages = 0
        
        for pkg in self.packages:
            if pkg.vulnerabilities:
                vulnerable_packages += 1
                counts = pkg.get_severity_counts()
                for sev, count in counts.items():
                    severity_counts[sev] += count
        
        return {
            'total_dependencies': self.total_dependencies,
            'vulnerable_packages': vulnerable_packages,
            'total_vulnerabilities': self.total_vulnerabilities,
            'critical': severity_counts['CRITICAL'],
            'high': severity_counts['HIGH'],
            'medium': severity_counts['MEDIUM'],
            'low': severity_counts['LOW'],
            'info': severity_counts['INFO'],
            'scan_duration': f"{self.scan_duration:.2f}s",
            'scan_timestamp': self.scan_timestamp
        }
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        import re
        
        return {
            'project_path': self.project_path,
            'scan_timestamp': self.scan_timestamp,
            'summary': self.get_summary(),
            'packages': [
                {
                    'package': pkg.dependency.package,
                    'version': pkg.dependency.version,
                    'ecosystem': pkg.dependency.ecosystem,
                    'source_file': pkg.dependency.source_file,
                    'vulnerability_count': pkg.get_total_count(),
                    'highest_severity': pkg.get_highest_severity(),
                    'vulnerabilities': [
                        self._format_vulnerability(v)
                        for v in pkg.vulnerabilities
                    ]
                }
                for pkg in self.packages if pkg.vulnerabilities
            ],
            'errors': self.errors
        }
    
    def _format_vulnerability(self, v: 'Vulnerability') -> Dict[str, Any]:
        """Format a single vulnerability with CVE ID extraction"""
        import re
        
        # Extract CVE IDs from multiple sources
        cve_ids = []
        
        # Check if the main ID is a CVE
        if v.id.startswith('CVE-'):
            cve_ids.append(v.id)
        
        # Check aliases field for CVE IDs
        for alias in v.aliases:
            if alias.startswith('CVE-') and alias not in cve_ids:
                cve_ids.append(alias)
        
        # Check references for CVE URLs
        for ref in v.references:
            if 'CVE-' in ref:
                # Extract CVE number from URL or text
                cve_match = re.search(r'CVE-\d{4}-\d+', ref)
                if cve_match:
                    cve_num = cve_match.group(0)
                    if cve_num not in cve_ids:
                        cve_ids.append(cve_num)
        
        # Prepare fixed_versions list (GUI expects array)
        fixed_versions = []
        if v.fixed_version:
            # If it's a comma-separated string, split it
            if ',' in v.fixed_version:
                fixed_versions = [ver.strip() for ver in v.fixed_version.split(',')]
            else:
                fixed_versions = [v.fixed_version]
        
        return {
            'id': v.id,
            'summary': v.summary,
            'severity': v.severity,
            'source': v.source,
            'cvss_score': v.cvss_score,
            'exploit_available': v.exploit_available,
            'fixed_version': v.fixed_version,
            'fixed_versions': fixed_versions,  # GUI expects this (plural)
            'references': v.references,
            'published_date': v.published_date,
            'aliases': v.aliases,
            'cve_ids': cve_ids  # Extracted CVE IDs for easy display
        }






